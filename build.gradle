import org.apache.tools.ant.filters.*;

buildscript {
	repositories {
		jcenter()
	}
}

plugins {
	id 'com.github.ben-manes.versions' version '0.17.0'
	id 'com.diffplug.gradle.spotless' version '3.8.0'
	id 'com.github.kt3k.coveralls' version '2.8.2'
	id 'org.sonarqube' version '2.6.1'
}

repositories {
	jcenter()
}

apply plugin: 'com.diffplug.gradle.spotless'
apply plugin: 'distribution'
apply plugin: 'com.github.kt3k.coveralls'

group = "net.sourceforge.fullsync"
version = '0.11.0'

spotless {
	encoding 'UTF-8'
}

subprojects {
	buildscript {
		repositories {
			jcenter()
		}
	}
	group = rootProject.group
	version = rootProject.version
	apply plugin: 'com.diffplug.gradle.spotless'
	apply plugin: 'jacoco'

	def subproject = delegate
	plugins.withType(JavaPlugin).whenPluginAdded { p ->
		sourceCompatibility = 1.8
		targetCompatibility = 1.8
		jar {
			manifest {
				attributes 'License': 'GPLv2+'
				attributes 'FullSync-Version': version
				attributes 'Copyright': 'Copyright (c) 2018 the FullSync Team'
			}
		}
		spotless {
			java {
				licenseHeaderFile rootProject.file('resources/License-header.txt')
				eclipse('4.7.1').configFile rootProject.file('resources/eclipse-jdt-formatter.xml')
				removeUnusedImports()
				trimTrailingWhitespace()
				endWithNewline()
			}
		}
		jacocoRootReport.dependsOn subproject.tasks.jacocoTestReport
	}

	ext {
		swtVersion = "3.106.2"
		slf4jVersion = "1.7.25"
		commonsCliVersion = "1.4"
		commonsNetVersion = "3.6"
		commonsVfsVersion = "2.2"
		sambaJcifsVersion = "1.3.17"
		jcraftJschVersion = "0.1.54"
		junitVersion = "4.12"
	}

	repositories {
		jcenter()
	}
}

wrapper {
	gradleVersion = '4.4'
	distributionType = Wrapper.DistributionType.ALL
}

task renderChangeLog(type: JavaExec) {
	dependsOn ':fullsync-build-utils:jar'
	main = 'net.sourceforge.fullsync.build.tools.ChangeLogGenerator'
	def versionsDir = file("versions")
	def changelogFile = file("$buildDir/ChangeLog.txt")
	inputs.file(fileTree(versionsDir) {
		include "*.html"
	})
	outputs.files changelogFile
	def allArgs = []
	allArgs << "--src-dir"
	allArgs << versionsDir
	allArgs << "--pattern"
	allArgs << ".*\\.html"
	allArgs << "--changelog"
	allArgs << changelogFile
	args allArgs
	doFirst {
		file(buildDir).mkdir()
	}
}

def eolFilter(context, eol) {
	context.filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance(eol))
}

def manualCopySpec = copySpec {
	into('docs/manual') {
		from('docs/manual') {
			include '**'
		}
		from('resources') {
			include 'fullsync.ico'
			rename('fullsync.ico', 'favicon.ico')
		}
	}
}

def versionsCopySpec = copySpec {
	into('versions') {
		from('versions') {
			include '*.html'
		}
	}
}

distributions {
	linux {
		contents {
			eachFile { file ->
				if (file.name.endsWith(".sh")) {
					file.mode = 0755
				}
				if ("fullsync.sh" == file.name) {
					file.name = "fullsync"
				}
			}
			from('LICENSE') {
				eolFilter(delegate, "lf")
				rename('LICENSE', 'LICENSE.txt')
			}
			from(renderChangeLog) {
				eolFilter(delegate, "lf")
			}
			from('resources/images') {
				include 'fullsync.svg'
			}
			with manualCopySpec
			with versionsCopySpec
		}
	}
	mac {
		contents {
			eachFile { file ->
				if (file.name.endsWith(".sh")) {
					file.mode = 0755
				}
				if ("fullsync.sh" == file.name) {
					file.name = "fullsync"
				}
			}
			from('LICENSE') {
				filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("lf"))
				rename('LICENSE', 'LICENSE.txt')
			}
			from(renderChangeLog) {
				eolFilter(delegate, "lf")
			}
			with manualCopySpec
			with versionsCopySpec
		}
	}
	windows {
		contents {
			from('resources') {
				include 'fullsync*.exe'
				include 'fullsync*.ini'
			}
			from('LICENSE') {
				eolFilter(delegate, "crlf")
				rename('LICENSE', 'LICENSE.txt')
			}
			from(renderChangeLog) {
				eolFilter(delegate, "crlf")
			}
			with manualCopySpec
			with versionsCopySpec
		}
	}
}

distZip.enabled = false
distTar.enabled = false
linuxDistZip.enabled = false
macDistZip.enabled = false
windowsDistTar.enabled = false

tasks.withType(Tar) {
	compression = Compression.GZIP
}

installLinuxDist.dependsOn ':fullsync-ui:jar'
linuxDistTar.dependsOn ':fullsync-ui:jar'

installMacDist.dependsOn ':fullsync-ui:jar'
macDistTar.dependsOn ':fullsync-ui:jar'

installWindowsDist.dependsOn ':fullsync-ui:jar'
windowsDistZip.dependsOn ':fullsync-ui:jar'
installWindowsDist.dependsOn ':fullsync-launcher:jar'
windowsDistZip.dependsOn ':fullsync-launcher:jar'

assembleDist {
	dependsOn assembleLinuxDist
	dependsOn assembleMacDist
	dependsOn assembleWindowsDist
}

installDist {
	dependsOn installLinuxDist
	dependsOn installMacDist
	dependsOn installWindowsDist
}

def mapArtifactToFilename(a) {
	def group = a.moduleVersion.id.group
	def classifier = a.classifier ?: ""
	classifier = classifier ? "-${classifier}" : ""
	return "${group}-${a.name}${classifier}.${a.extension}"
}

gradle.projectsEvaluated {
	def buildUltils = project(':fullsync-build-utils')
	renderChangeLog.classpath = buildUltils.configurations.runtime + buildUltils.jar.outputs.files

	def ui = project(':fullsync-ui')
	def resolvedUiDist = ui.configurations.dist.resolvedConfiguration
	def commonContents = copySpec {}
	resolvedUiDist.resolvedArtifacts.each { a ->
		commonContents.with copySpec {
			def f = a.file
			into('lib') {
				from(f.path) {
					rename(f.name, mapArtifactToFilename(a))
				}
			}
		}
	}
	commonContents.with copySpec {
		into('lib') {
			from resolvedUiDist.files - resolvedUiDist.resolvedArtifacts*.file
		}
	}
	distributions.linux.contents.with commonContents
	distributions.mac.contents.with commonContents
	distributions.windows.contents.with commonContents

	def launcher = project(':fullsync-launcher')
	def resolvedLauncherDist = launcher.configurations.dist.resolvedConfiguration
	resolvedLauncherDist.resolvedArtifacts.each { a ->
		distributions.windows.contents.with  copySpec {
			def f = a.file
			into('lib') {
				from(f.path) {
					rename(f.name, mapArtifactToFilename(a))
				}
			}
		}
	}

	subprojects.findAll { subproject ->
		subproject.pluginManager.hasPlugin('java')
	}.each { subproject ->
		jacocoRootReport.sourceDirectories = jacocoRootReport.sourceDirectories + subproject.jacocoTestReport.sourceDirectories
		jacocoRootReport.classDirectories = jacocoRootReport.classDirectories + subproject.jacocoTestReport.classDirectories
		jacocoRootReport.executionData = jacocoRootReport.executionData + subproject.jacocoTestReport.executionData
		coveralls.sourceDirs += subproject.sourceSets.main.allSource.srcDirs.flatten()
	}
}

apply plugin: 'jacoco'

jacoco {
	reportsDir = file("${project.reporting.baseDir}/jacoco")
}

task jacocoRootReport(type: JacocoReport) {
	sourceDirectories = files()
	classDirectories = files()
	executionData = files()
	reports {
		html.enabled = true
		xml.enabled = true
		csv.enabled = false
	}

	// Work-around to allow us to build list of executionData files in doFirst
	onlyIf = {
		true
	}

	doFirst {
		executionData = files(executionData.findAll {
			it.exists()
		})
	}
}

coveralls {
	jacocoReportPath = "${project.reporting.baseDir}/jacoco/jacocoRootReport/jacocoRootReport.xml"
}

tasks.coveralls {
	group = 'Coverage reports'
	description = 'Uploads the aggregated coverage report to Coveralls'

	dependsOn jacocoRootReport
	onlyIf {
		System.env.'CI'
	}
}

task run(type: JavaExec) {
	dependsOn installLinuxDist
	main = '-jar'
	args = ["${buildDir}/install/${project.name}-linux/lib/net.sourceforge.fullsync-fullsync-core.jar", "-v"]
}

task debug(type: JavaExec) {
	dependsOn installLinuxDist
	main = '-jar'
	args = ["${buildDir}/install/${project.name}-linux/lib/net.sourceforge.fullsync-fullsync-core.jar", "-v"]
	debug = true
	enableAssertions = true
}

task debugLauncher(type: JavaExec) {
	dependsOn installWindowsDist
	main = '-jar'
	args = ["${buildDir}/install/${project.name}-windows/lib/net.sourceforge.fullsync-fullsync-launcher.jar", "-v"]
	debug = true
	enableAssertions = true
}

tasks.sonarqube {
	onlyIf {
		System.properties.'sonar.host.url'
	}
}

dependencyUpdates {
  revision = "release"
  outputFormatter = "text"
  resolutionStrategy = {
    componentSelection { rules ->
      rules.all { ComponentSelection selection ->
        boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm'].any { qualifier ->
          selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
        }
        if (rejected) {
          selection.reject('Release candidate')
        }
        else {
          rejected = selection.candidate.version.contains('-');
          if (rejected) {
            selection.reject('SNAPSHOT version')
          }
        }
      }
    }
  }
}
